<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>event_loop</title>
    <url>/my-blog/event-loop.html</url>
    <content><![CDATA[<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><blockquote>
<p>事件循环机制</p>
</blockquote>
<p><code>JavaScript</code>是单线程的，事件循环就是解决其运行阻塞的一种机制</p>
<p>宏任务：script，<code>setTimeout</code>，<code>setInternal</code>,<code>setImmediate</code>,I/O，<code>UI</code>事件</p>
<p>微任务：process，<code>nextTick</code>，Promise，<code>Object.observe</code>,<code>MutationObserver</code></p>
<p><strong>1. 主线程执行任务，会形成一个执行栈，从任务列表中读取任务是循环不断的，这个运行机制形成了事件循环，</strong></p>
<p><strong>2. 执行第一个宏任务，依次执行代码，遇到微任务推到微任务队列中，遇到宏任务放到宏任务队列中</strong></p>
<p><strong>3. 执行完第一个宏任务中的非宏任务和非微任务代码后，取出所有的微任务，执行完</strong></p>
<p><strong>4. 取出宏任务队列首个宏任务，按照步骤2,步骤3，步骤4循环执行，直到所有的执行完</strong></p>
<p><strong>注意：对于所有的同步任务来说，同步用会在主线程形成一个执行栈</strong></p>
<p><strong>对于异步任务，等待某个时机，触发线程，将回调函数加到队列中执行</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">t</span> =&gt;</span> <span class="built_in">console</span>.log(t));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>依次会输出：4，3，2，1</p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>wheel_01</title>
    <url>/my-blog/wheel-01.html</url>
    <content><![CDATA[<h3 id="吸顶效果"><a href="#吸顶效果" class="headerlink" title="吸顶效果"></a><a href="https://tomoyd.github.io/wheels/top-style">吸顶效果</a></h3>]]></content>
      <tags>
        <tag>轮子</tag>
      </tags>
  </entry>
  <entry>
    <title>fullScene</title>
    <url>/my-blog/fullScene.html</url>
    <content><![CDATA[<h2 id="浏览器全屏"><a href="#浏览器全屏" class="headerlink" title="浏览器全屏"></a>浏览器全屏</h2><p>实现全屏功能，首先要考虑到的是浏览器兼容的问题，各个浏览器的全屏实现方法及标准的实现方法;其次要考虑到功能完整性，开启全屏和关闭全屏应是一致出现的,<a href="https://tomoyd.github.io/FrontedTechStack/demo/FullScreen/full-screen">预览地址</a></p>
<a id="more"></a>
<h2 id="全屏方法处理"><a href="#全屏方法处理" class="headerlink" title="全屏方法处理"></a>全屏方法处理</h2><p>调用dom元素的标准全屏方法requestFullScreen()，考虑到兼容各个浏览器故有以下代码 ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getMyRequestFullScreen=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> myEl = <span class="built_in">document</span>.documentElement;</span><br><span class="line">    <span class="keyword">return</span> myEl.requestFullScreen||myEl.webkitRequestFullScreen</span><br><span class="line">    ||myEl.mozRequestFullScreen||myEl.msRequestFullScreen</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用得到通用的函数句柄</span></span><br><span class="line"><span class="keyword">let</span> openFullScreen=getMyRequestFullScreen()</span><br><span class="line"><span class="comment">// 为函数指定this的值，这里使用call（），这里假设targetElement为我们所要全屏的对象</span></span><br><span class="line">openFullScreen.call(targetElement)</span><br></pre></td></tr></table></figure>

<h2 id="退出全屏处理"><a href="#退出全屏处理" class="headerlink" title="退出全屏处理"></a>退出全屏处理</h2><p>退出全屏，需要调用document的标准方法exitFullscreen(),兼容各个浏览器故有：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getExitFullScreen=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">document</span>.exitFullScreen||<span class="built_in">document</span>.mozCancelFullScreen||</span><br><span class="line">	<span class="built_in">document</span>.webkitCancelScreen||<span class="built_in">document</span>.msExitFullScreen</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> exitFullScreen=getExitFullScreen()</span><br><span class="line">exitFullScreen.call(targetElement)</span><br></pre></td></tr></table></figure>

<h2 id="判断是否处于全屏"><a href="#判断是否处于全屏" class="headerlink" title="判断是否处于全屏"></a>判断是否处于全屏</h2><p>标准属性fullscreenElement是否为null可以判断，考虑到各个浏览器兼容性故有：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isFullScreen=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">document</span>.fullscreenElement&amp;&amp;<span class="built_in">document</span>.fullscreenElement!==<span class="literal">null</span>)||</span><br><span class="line">        <span class="built_in">document</span>.webkitIsFullScreen||<span class="built_in">document</span>.mozFullScreen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="综合上述"><a href="#综合上述" class="headerlink" title="综合上述"></a>综合上述</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handleFullScreen=<span class="function">(<span class="params">targetElement</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> openFullScreen=getMyRequestFullScreen()</span><br><span class="line">	<span class="keyword">let</span> shutFullScreen=getExitFullScreen()</span><br><span class="line">	<span class="keyword">let</span> isFull=isFullScreen()</span><br><span class="line">	<span class="keyword">if</span>(isFull)&#123;</span><br><span class="line">		shutFullScreen()</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        openFullScreen()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dom</tag>
      </tags>
  </entry>
  <entry>
    <title>a 标签</title>
    <url>/my-blog/aTag.html</url>
    <content><![CDATA[<h2 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a>使用背景</h2><p>a 标签在实际开发过程中是会常用到，比如<strong>下载，跳转页面，导航</strong>等功能的实现</p>
<h2 id="实现下载"><a href="#实现下载" class="headerlink" title="实现下载"></a>实现下载</h2><p>有三种方式可以实现，<a href="https://tomoyd.github.io/hexo-blog/demos/aTag/download.html">示例地址</a></p>
<a id="more"></a>
<ul>
<li><p>直接使用<code>href</code>属性链接到资源地址</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"资源地址"</span>&gt;</span>下载<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>加入download属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"资源地址"</span> <span class="attr">download</span>&gt;</span>下载<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这两种方式其实可以看做是一种下载方式，不带download属性时，浏览器会执行默认行为，即浏览器能打开预览的则打开预览，否则直接下载</p>
<ul>
<li><p>JavaScript 实现下载</p>
<p>这种方式本质上也是创建一个可以链接资源的标签，然后进行手动点击，触发资源请求下载,本主题当然是使用a标签了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downloadFile</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> aTag=<span class="built_in">document</span>.createElement(<span class="string">'a'</span>)</span><br><span class="line">         aTag.download=<span class="string">"text.txt"</span></span><br><span class="line">         aTag.style.display=<span class="string">'none'</span></span><br><span class="line">  </span><br><span class="line">         <span class="comment">//    创建a标签的href连接的地址</span></span><br><span class="line">         aTag.href=<span class="string">"资源地址"</span></span><br><span class="line">         <span class="comment">//    手动点击</span></span><br><span class="line">         aTag.click();</span><br><span class="line">         aTag=<span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种需求就是<strong>导出</strong>功能，其实导出的话其原理是一致的，只是需要自己根据内容<strong>创建URL地址</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建内容的连接地址</span></span><br><span class="line"><span class="keyword">let</span> blobContent=<span class="keyword">new</span> Blob([content]) <span class="comment">// content 为我们要导出的内容</span></span><br><span class="line"><span class="keyword">let</span> urlContent = URL.createObjectURL(blobContent)</span><br><span class="line"><span class="comment">//urlContent赋给href属性即可</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="跳转链接"><a href="#跳转链接" class="headerlink" title="跳转链接"></a>跳转链接</h2><pre><code>    跳转需要考虑的一个问题是：跳转页面在什么地方展示，比如在整个窗口，在本页面的某个位置或者在新标签页展示
需要用的一个属性就是target属性，它的属性值决定了在哪里打开链接文档
其属性值可以为 _self(默认),_top(整个浏览器窗口打开)，_parent(在父级框架打开)，_blank(在新空白页打开)
也可以是iframename
可以认为_self,_parent,_blank,_top都是iframe的属性name的值，只不过这些值是HTML已经定义好的</code></pre><p><a href="https://tomoyd.github.io/hexo-blog/demos/aTag/nav.html">预览地址</a></p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>a 标签</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 搭建个人博客</title>
    <url>/my-blog/index.html</url>
    <content><![CDATA[<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>npm install -g hexo</p>
<h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>命令行输入 <code>hexo init blogname</code></p>
<h2 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h2><p>下载next主题</p>
<h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">官网文档配置链接</a></p>
]]></content>
      <categories>
        <category>个人向</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
